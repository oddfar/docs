---
title: JUC学习笔记（一）
permalink: /java/se/thread/study-note
date: 2021-05-15 18:09:11
---

# JUC

## 一 简介



### 什么是JUC

JUC是java.util.concurrent 的简写，在并发编程中使用的工具类。

在jdk官方手册中可以看到juc相关的jar包有三个。

用中文概括一下，JUC的意思就是java并发编程工具包

实现多线程有三种方式：Thread、Runnable、Callable，其中Callable就位于concurrent包下 

### 进程和线程

>  进程 / 线程是什么？

进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义，线程可以利用进程所有拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程小，基本上不拥有系统资源， 故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。

白话： 

进程：就是操作系统中运行的一个程序，QQ.exe，music.exe，word.exe ，这就是多个进程 

线程：每个进程中都存在一个或者多个线程，比如用word写文章时，就会有一个线程默默帮你定时自动保存。

> 并发 / 并行是什么？

做并发编程之前，必须首先理解什么是并发，什么是并行。

并发和并行是两个非常容易混淆的概念。它们都可以表示两个或多个任务一起执行，但是偏重点有点不同。并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。然而并行的偏重点在于”同时执行”。

严格意义上来说，并行的多个任务是真实的同时执行，而对于并发来说，这个过程只是交替的，一会运行任务一,一会儿又运行任务二，系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务是串行并发的，也会造成是多个任务并行执行的错觉。

实际上，如果系统内只有一个CPU，而现在而使用多线程或者多线程任务，那么真实环境中这些任务不可能真实并行的，毕竟一个CPU一次只能执行一条指令，这种情况下多线程或者多线程任务就是并发的，而不是并行，操作系统会不停的切换任务。真正的并发也只能够出现在拥有多个CPU的系统中（多核CPU）。

**并发的动机**：在计算能力恒定的情况下处理更多的任务, 就像我们的大脑, 计算能力相对恒定, 要在一天中处理更多的问题, 我们就必须具备多任务的能力. 现实工作中有很多事情可能会中断你的当前任务, 处理这种多任务的能力就是你的并发能力。

**并行的动机**：用更多的CPU核心更快的完成任务. 就像一个团队, 一个脑袋不够用了, 一个团队来一起处理 一个任务。

例子：
你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 （不一定是
同时的）
你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

 

> 线程的状态

Java的线程有6种状态：可以分析源码：

```java
public enum State {
    //线程刚创建
    NEW,
    
    //在JVM中正在运行的线程
    RUNNABLE,
    
    //线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行
    BLOCKED,
    
    //等待状态
    WAITING,
    
    //调用sleep() join() wait()方法可能导致线程处于等待状态
    TIMED_WAITING,
    
    //线程执行完毕，已经退出
    TERMINATED;
}
```

![image-20210513145542628](https://cdn.jsdelivr.net/gh/oddfar/static/img/JUC学习笔记.assets/image-20210513145542628.png)

> wait / sleep 的区别

**1、来自不同的类**

这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。

sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。

**2、有没有释放锁(释放资源)**

最主要是sleep方法没有释放锁

而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。



sleep是线程被调用时，占着cpu去睡觉，其他线程不能占用cpu，os认为该线程正在工作，不会让出系统资源，wait是进入等待池等待，让出系统资源，其他线程可以占用cpu。



sleep(100L)是占用cpu，线程休眠100毫秒，其他进程不能再占用cpu资源，wait（100L）是进入等待池中等待，交出cpu等系统资源供其他进程使用，在这100毫秒中，该线程可以被其他线程notify，但不同的是其他在等待池中的线程不被notify不会出来，但这个线程在等待100毫秒后会自动进入就绪队列等待系统分配资源，换句话说，sleep（100）在100毫秒后肯定会运行，但wait在100毫秒后还有等待os调用分配资源，所以wait100的停止运行时间是不确定的，但至少是100毫秒。
就是说sleep有时间限制的就像闹钟一样到时候就叫了，而wait是无限期的除非用户主动notify。

**3、使用范围不同**

wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用

```java
synchronized(x){
    //或者wait()
    x.notify()
}
```

**4、是否需要捕获异常** 

sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常

## 二 Lock锁

### synchronized锁

```java
public class SaleTicketTest1 {
    /*
     * 题目：三个售票员 卖出 30张票
     * 多线程编程的企业级套路：
     * 1. 在高内聚低耦合的前提下， 线程 操作(对外暴露的调用方法) 资源类
     */

    public static void main(String[] args) {
        Ticket ticket = new Ticket();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <= 40; i++) {
                    ticket.saleTicket();
                }
            }
        }, "A").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <=40; i++) {
                    ticket.saleTicket();
                }
            }
        }, "B").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <= 40; i++) {
                    ticket.saleTicket();
                }
            }
        }, "C").start();

    }
    
}

class Ticket { // 资源类
    private int number = 30;

    public synchronized void saleTicket() {
        if (number > 0) {
            System.out.println(Thread.currentThread().getName() + "卖出第 " + (number--) + "票,还剩下:" + number);
        }
    }
}
```

### Lock 锁

```java
public class SaleTicketTest2 {
    public static void main(String[] args) {
        Ticket2 ticket2 = new Ticket2();

        new Thread(() -> {
            for (int i = 1; i <= 40; i++) {
                ticket2.saleTicket();
            }
        }, "A").start();

        new Thread(() -> {
            for (int i = 1; i <= 40; i++) {
                ticket2.saleTicket();
            }
        }, "B").start();

        new Thread(() -> {
            for (int i = 1; i <= 40; i++) {
                ticket2.saleTicket();
            }
        }, "C").start();

    }
}

class Ticket2 { // 资源类
    private Lock lock = new ReentrantLock();

    private int number = 30;

    public void saleTicket() {
        lock.lock();

        try {
            if (number > 0) {
                System.out.println(Thread.currentThread().getName() + "卖出第 " + (number--) + "票,还剩下:" + number);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }
}
```

###  区别

1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放
锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1
阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以
不用一直等待就结束了；
5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

##  三 生产者和消费者

### synchroinzed 

生产者和消费者 synchroinzed 版

```java
public class ProducerConsumer {
    /**
     * 题目：现在两个线程，可以操作初始值为0的一个变量
     * 实现一个线程对该变量 + 1，一个线程对该变量 -1
     * 实现交替10次
     * <p>
     * 诀窍：
     * 1. 高内聚低耦合的前提下，线程操作资源类
     * 2. 判断 、干活、通知
     */

    public static void main(String[] args) {
        Data data = new Data();

        //A线程增加
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "A").start();

        //B线程减少
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "B").start();
    }
}

class Data {
    private int number = 0;

    public synchronized void increment() throws InterruptedException {
        // 判断该不该这个线程做
        if (number != 0) {
            this.wait();
        }
        // 干活
        number++;
        System.out.println(Thread.currentThread().getName() + "\t" + number);
        // 通知
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        // 判断该不该这个线程做
        if (number == 0) {
            this.wait();
        }
        // 干活
        number--;
        System.out.println(Thread.currentThread().getName() + "\t" + number);
        // 通知
        this.notifyAll();
    }

}
```

问题升级：防止虚假唤醒，4个线程，两个加，两个减

【重点】if 和 while

```java
public class ProducerConsumerPlus {
    /**
     * 题目：现在四个线程，可以操作初始值为0的一个变量
     * 实现两个线程对该变量 + 1，两个线程对该变量 -1
     * 实现交替10次
     *
     * 诀窍：
     * 1. 高内聚低耦合的前提下，线程操作资源类
     * 2. 判断 、干活、通知
     * 3. 多线程交互中，必须要防止多线程的虚假唤醒，即（判断不能用if，只能用while）
     */

    public static void main(String[] args) {
        Data2 data = new Data2();

        //A线程增加
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "A").start();

        //B线程减少
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "B").start();

        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "C").start();

        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "D").start();
    }
}

class Data2 {
    private int number = 0;

    public synchronized void increment() throws InterruptedException {
        // 判断该不该这个线程做
        while (number != 0) {
            this.wait();
        }
        // 干活
        number++;
        System.out.println(Thread.currentThread().getName() + "\t" + number);
        // 通知
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        // 判断该不该这个线程做
        while (number == 0) {
            this.wait();
        }
        // 干活
        number--;
        System.out.println(Thread.currentThread().getName() + "\t" + number);
        // 通知
        this.notifyAll();
    }

}
```



### lock



```java
public class ProducerConsumerPlus {
    /**
     * 题目：现在四个线程，可以操作初始值为0的一个变量
     * 实现两个线程对该变量 + 1，两个线程对该变量 -1
     * 实现交替10次
     * <p>
     * 诀窍：
     * 1. 高内聚低耦合的前提下，线程操作资源类
     * 2. 判断 、干活、通知
     * 3. 多线程交互中，必须要防止多线程的虚假唤醒，即（判断不能用if，只能用while）
     */

    public static void main(String[] args) {
        Data2 data = new Data2();

        //A线程增加
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "A").start();

        //B线程减少
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "B").start();

        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "C").start();

        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "D").start();
    }
}

class Data2 {
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void increment() throws InterruptedException {

        lock.lock();
        try {
            // 判断该不该这个线程做
            while (number != 0) {
                condition.await();
            }
            // 干活
            number++;
            System.out.println(Thread.currentThread().getName() + "\t" + number);
            // 通知
            condition.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void decrement() throws InterruptedException {
        lock.lock();
        try {
            // 判断该不该这个线程做
            while (number == 0) {
                condition.await();
            }
            // 干活
            number--;
            System.out.println(Thread.currentThread().getName() + "\t" + number);
            // 通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
```

以上写的程序并不会按照ABCD线程顺序，只会按照 “生产” “消费”顺序

### 按照线程顺序执行

精确通知顺序访问

```java
public class c {
    /**
     * 题目：多线程之间按顺序调用，实现 A->B->C
     * 重点：标志位
     */

    public static void main(String[] args) {
        Resources resources = new Resources();

        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                resources.a();
            }

        }, "A").start();

        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                resources.b();
            }

        }, "B").start();

        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                resources.c();
            }

        }, "C").start();

    }
}

class Resources {
    private int number = 1; // 1A 2B 3C
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    public void a() {
        lock.lock();
        try {
            // 判断
            while (number != 1) {
                condition1.await();
            }
            // 干活
            System.out.println(Thread.currentThread().getName());
            // 通知,指定的干活！
            number = 2;
            condition2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void b() {
        lock.lock();
        try {
            // 判断
            while (number != 2) {
                condition2.await();
            }
            // 干活
            System.out.println(Thread.currentThread().getName() );

            // 通知,指定的干活！
            number = 3;
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void c() {
        lock.lock();
        try {
            // 判断
            while (number != 3) {
                condition3.await();
            }
            // 干活
            System.out.println(Thread.currentThread().getName());

            // 通知,指定的干活！
            number = 1;
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

