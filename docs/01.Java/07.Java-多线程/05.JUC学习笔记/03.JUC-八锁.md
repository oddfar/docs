---
title: JUC学习笔记-8锁的现象
permalink: /java/se/thread/study-note/2
date: 2021-05-16 11:01:20
---

# 8锁的现象

## 问题一

1、标准访问，请问先打印邮件还是短信？

```java
package com.oddfar.lock8;

import java.util.concurrent.TimeUnit;

public class A {
    /**
     * 多线程的8锁
     * 1、标准访问，请问先打印邮件还是短信？
     */
    public static void main(String[] args) throws InterruptedException {
        Phone phone = new Phone();
        new Thread(() -> {
            try {
                phone.sendEmail();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "A").start();

        //休眠一秒
        //Thread.sleep(1000);
        TimeUnit.SECONDS.sleep(1);
        
        new Thread(() -> {
            try {
                phone.sendSMS();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "B").start();

    }
}

class Phone {
    public synchronized void sendEmail(){
        System.out.println("sendEmail");
    }

    public synchronized void sendSMS(){
        System.out.println("sendSMS");
    }
}

```

答案：sendEmail

结论：被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行。



## 问题二

2、邮件方法暂停4秒钟，请问先打印邮件还是短信？

```java
package com.oddfar.lock8;

import java.util.concurrent.TimeUnit;

public class B {
    /**
     * 多线程的8锁
     * 2、邮件方法暂停4秒钟，请问先打印邮件还是短信？
     */
    public static void main(String[] args) throws InterruptedException {
        Phone2 phone = new Phone2();
        new Thread(() -> {
            try {
                phone.sendEmail();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "A").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                phone.sendSMS();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "B").start();

    }
}

class Phone2 {
    public synchronized void sendEmail() throws Exception {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("sendEmail");
    }

    public synchronized void sendSMS(){
        System.out.println("sendSMS");
    }
}
```

答案：sendEmail  

结论：被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行，第二个方法只有在第一个方法执行完释放锁之后才能执行。

## 问题三

3、新增一个普通方法hello()不加锁，请问先打印邮件还是hello？

```java
package com.oddfar.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @author zhiyuan
 */
public class C {
    /**
     * 多线程的8锁
     * 3、新增一个普通方法hello()不加锁，请问先打印邮件还是hello？
     */
    public static void main(String[] args) throws InterruptedException {
        Phone3 phone = new Phone3();
        new Thread(() -> {
            try {
                phone.sendEmail();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "A").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                phone.hello();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "B").start();

    }
}

class Phone3 {
    public synchronized void sendEmail() throws Exception {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("sendEmail");
    }
    
    // 没有 synchronized，没有 static 就是普通方式
    public void hello() {
        System.out.println("Hello");
    }
}
```

答案：Hello

结论：如果一个方法没有被synchronized修饰，不是同步方法，不受锁的影响，所以不需要等待。

## 问题四

4、两个手机，一个手机发邮件，另一个发短信，请问先执行sendEmail 还是 sendSMS

```java
package com.oddfar.lock8;

import java.util.concurrent.TimeUnit;

public class D {
    /**
     * 多线程的8锁
     * 4、两个手机，请问先执行sendEmail 还是 sendSMS
     */
    public static void main(String[] args) throws InterruptedException {
        Phone4 phone = new Phone4();
        Phone4 phone2 = new Phone4();

        new Thread(() -> {
            try {
                phone.sendEmail();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "A").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                phone2.sendSMS();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "B").start();

    }
}

class Phone4 {
    public synchronized void sendEmail() throws Exception {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("sendEmail");
    }

    public synchronized void sendSMS() {
        System.out.println("sendSMS");
    }
}
```



答案：先执行“sendSMS”

结论：被synchronized修饰的方法，锁的对象是方法的调用者。用了两个对象调用各自的方法，所以两个方法的调用者不是同一个，于是两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。

## 问题五

5、两个静态同步方法，同一部手机，请问先打印邮件还是短信？

```java
package com.oddfar.lock8;

import java.util.concurrent.TimeUnit;

public class E {
    /**
     * 多线程的8锁
     * 5、两个静态同步方法，同一部手机，请问先打印邮件还是短信？
     */
    public static void main(String[] args) throws InterruptedException {
        Phone5 phone = new Phone5();

        new Thread(() -> {
            try {
                phone.sendEmail();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "A").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                phone.sendSMS();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "B").start();

    }
}

class Phone5 {
    public static synchronized void sendEmail() throws Exception {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("sendEmail");
    }

    public static synchronized void sendSMS() {
        System.out.println("sendSMS");
    }
}
```



答案：先执行“sendEmail”

结论：被synchronized和static修饰的方法，锁的对象是类的class模板对象，这个则全局唯一！两个方法都被static修饰了，所以两个方法用的是同一个锁，后调用的方法需要等待先调用的方法。

## 问题六

6、两个静态同步方法，2部手机，一个手机发邮件，另一个发短信，请问先打印邮件还是短信？

```java
package com.oddfar.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @author zhiyuan
 */
public class F {
    /**
     * 多线程的8锁
     * 6、两个静态同步方法，2部手机，一个手机发邮件，另一个发短信，请问先打印邮件还是短信？
     */
    public static void main(String[] args) throws InterruptedException {
        Phone6 phone = new Phone6();

        Phone6 phone2 = new Phone6();

        new Thread(() -> {
            try {
                phone.sendEmail();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "A").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                phone2.sendSMS();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "B").start();

    }
}

class Phone6 {
    public static synchronized void sendEmail() throws Exception {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("sendEmail");
    }

    public static synchronized void sendSMS() {
        System.out.println("sendSMS");
    }
}
```

答案：先输出“sendEmail”

结论：被synchronized和static修饰的方法，锁的对象就是Class模板对象，这个则全局唯一！所以说这里是同一个

## 问题七

7、一个普通同步方法，一个静态同步方法，同一部手机，请问先打印邮件还是短信？

```java
package com.oddfar.lock8;

import java.util.concurrent.TimeUnit;

public class G {
    /**
     * 多线程的8锁
     * 7、一个普通同步方法，一个静态同步方法，同一部手机，请问先打印邮件还是短信？
     */
    public static void main(String[] args) throws InterruptedException {
        Phone7 phone = new Phone7();

        new Thread(() -> {
            try {
                phone.sendEmail();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "A").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                phone.sendSMS();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "B").start();

    }
}

class Phone7 {
    public static synchronized void sendEmail() throws Exception {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("sendEmail");
    }

    public synchronized void sendSMS() {
        System.out.println("sendSMS");
    }
}
```

答案：先执行“sendSMS”

结论：synchronized 锁的是这个调用的对象。被synchronized和static修饰的方法，锁的是这个类的Class模板 。这里是两个锁！

## 问题八

8、一个普通同步方法，一个静态同步方法，2部手机，一个发邮件，一个发短信，请问哪个先执行？

```java
package com.oddfar.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @author zhiyuan
 */
public class H {
    /**
     * 多线程的8锁
     * 8、一个普通同步方法，一个静态同步方法，2部手机，一个发邮件，一个发短信，请问先打印邮件还是短信？
     */
    public static void main(String[] args) throws InterruptedException {
        Phone8 phone = new Phone8();
        Phone8 phone2 = new Phone8();

        new Thread(() -> {
            try {
                phone.sendEmail();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "A").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                phone2.sendSMS();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "B").start();

    }
}

class Phone8 {
    public static synchronized void sendEmail() throws Exception {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("sendEmail");
    }

    public synchronized void sendSMS() {
        System.out.println("sendSMS");
    }
}
```

答案：sendSMS

结论：被synchronized和static修饰的方法，锁的对象是类的class对象。仅被synchronized修饰的方法，锁的对象是方法的调用者。即便是用同一个对象调用两个方法，锁的对象也不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。

## 小结

1、new this 调用的这个对象，是一个具体的对象！

2、static class 唯一的一个模板！

一个对象里面如果有多个synchronized方法，某个时刻内，只要一个线程去调用其中一个synchronized 方法了，其他的线程都要等待，换句话说，在某个时刻内，只能有唯一一个线程去访问这些 synchronized方法，锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的 synchronized方法

加个普通方法后发现和同步锁无关，换成两个对象后，不是同一把锁，情况变化

都换成静态同步方法后，情况又变化了。所有的非静态的同步方法用的都是同一把锁（锁的class模板）

**具体的表现为以下三种形式：** 

- 对于普通同步方法，锁的是当前实例对象 

- 对于静态同步方法，锁的是当前的Class对象。 

- 对于同步方法块，锁是synchronized括号里面的配置对象

当一个线程试图访问同步代码块时，他首先必须得到锁，退出或者是抛出异常时必须释放锁，也就是说 如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可以是别的实例对象非非静态同步方法因为跟该实例对象的非静态同步方法用 的是不同的锁，所以必须等待该实例对象已经获取锁的非静态同步方法释放锁就可以获取他们自己的 锁。

所有的静态同步方法用的也是同一把锁（类对象本身） ，这两把锁的是两个不同的对象，所以静态的同步方法与非静态的同步方法之间是不会有竞争条件的，但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要他们用一个的是同一个类的实例对象。