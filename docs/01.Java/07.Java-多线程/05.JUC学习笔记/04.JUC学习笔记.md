---
title: JUC学习笔记（二）
permalink: /java/se/thread/study-note/4
date: 2021-05-16 14:49:33
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [六 多线程下集合类的不安全](#%E5%85%AD-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8)
  - [list](#list)
  - [set](#set)
  - [map](#map)
- [七 Callable](#%E4%B8%83-callable)
  - [基础入门](#%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8)
  - [多个线程调用](#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8)
  - [参考资料](#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)
- [八 常用辅助类](#%E5%85%AB-%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB)
  - [CountDownLatch](#countdownlatch)
  - [CyclicBarrier](#cyclicbarrier)
  - [Semaphore](#semaphore)
- [九 读写锁](#%E4%B9%9D-%E8%AF%BB%E5%86%99%E9%94%81)
- [十 阻塞队列](#%E5%8D%81-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97)
  - [阻塞队列简介](#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B)
  - [阻塞队列的用处](#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%94%A8%E5%A4%84)
  - [接口架构图](#%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84%E5%9B%BE)
  - [API的使用](#api%E7%9A%84%E4%BD%BF%E7%94%A8)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 六 多线程下集合类的不安全

### list 

多线程下

```java
public class ListTest {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        // 对比3个线程 和 30个线程，看区别
        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
```

运行报错：`java.util.ConcurrentModificationException`

导致原因：add 方法没有加锁

解决方案：

```java
/**
 * 换一个集合类
 *  1、List<String> list = new Vector<>(); JDK1.0 就存在了！
 *  2、List<String> list = Collections.synchronizedList(new ArrayList<>());
 *  3、List<String> list = new CopyOnWriteArrayList<>();
 */
public class ListTest {
    public static void main(String[] args) {

        List<String> list = new CopyOnWriteArrayList<>();

        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
```

**写入时复制（CopyOnWrite）思想**

写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种优化策略。其核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本 （private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。

**CopyOnWriteArrayList为什么并发安全且性能比Vector好**

Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。

### set



```java
/**
 * 1、Set<String> set = Collections.synchronizedSet(new HashSet<>());
 * 2、Set<String> set = new CopyOnWriteArraySet();
 */
public class SetTest {
    public static void main(String[] args) {

        Set<String> set = new CopyOnWriteArraySet();

        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                set.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(set);
            }, String.valueOf(i)).start();
        }
    }
}
```

### map

hashMap底层是数组+链表+红黑树

```java
Map<String,String> map = new HashMap<>();
// 等价于
Map<String,String> map = new HashMap<>(16,0.75);
// 工作中，常常会自己根据业务来写参数，提高效率
```

map不安全测试：

```java
public class MapSet {
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>();

        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                map.put(Thread.currentThread().getName(),
                        UUID.randomUUID().toString().substring(0, 8));
                System.out.println(map);
            }, String.valueOf(i)).start();
        }
    }
}
```

解决：

```java
Map<String,String> map = new ConcurrentHashMap<>();
```

## 七 Callable

我们已经知道Java中常用的两种线程实现方式：分别是继承Thread类和实现Runnable接口。

![img](https://cdn.jsdelivr.net/gh/oddfar/static/img/JUC学习笔记.assets/95eef01f3a292df5cb9047105febf76635a87341.jpeg)

从上图中，我们可以看到，第三种实现Callable接口的线程，而且还带有返回值的。我们来对比下实现Runnable和实现Callable接口的两种方式不同点：

1：需要实现的方法名称不一样：一个run方法，一个call方法

2：返回值不同：一个void无返回值，一个带有返回值的。其中返回值的类型和泛型V是一致的。

3：异常：一个无需抛出异常，一个需要抛出异常。

### 基础入门

```java
public class CallableDemo {
    public static void main(String[] args) throws Exception {
        MyThread myThread = new MyThread();
        FutureTask futureTask = new FutureTask(myThread); // 适配类
        Thread t1 = new Thread(futureTask, "A"); // 调用执行
        t1.start();
        Integer result = (Integer) futureTask.get(); // 获取返回值
        System.out.println(result);
    }
}

class MyThread implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        System.out.println("call 被调用");
        return 1024;
    }
}
```

![image-20210516160612609](https://cdn.jsdelivr.net/gh/oddfar/static/img/JUC学习笔记.assets/image-20210516160612609.png)

### 多个线程调用

```java
public class CallableDemo {
    public static void main(String[] args) throws Exception {
        MyThread myThread = new MyThread();
        FutureTask futureTask = new FutureTask(myThread); // 适配类

        new Thread(futureTask, "A").start(); // 调用执行
        // 第二次调用执行，在同一个futureTask对象，不输出结果，可理解为“缓存”
        new Thread(futureTask, "B").start(); 

        //get 方法获得返回结果! 一般放在最后一行！否则可能会阻塞
        Integer result = (Integer) futureTask.get(); // 获取返回值
        System.out.println(result);
    }
}

class MyThread implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName() + "\tcall 被调用");
        TimeUnit.SECONDS.sleep(2);
        return 1024;
    }
}
```

### 参考资料

- https://baijiahao.baidu.com/s?id=1666820818587296272

## 八 常用辅助类

### CountDownLatch

“倒计时锁存器”

例如，执行完6个线程输出执行完毕

```java
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        // 计数器
        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\tStart");
                countDownLatch.countDown(); // 计数器-1
            }, String.valueOf(i)).start();
        }
        //阻塞等待计数器归零
        countDownLatch.await();
        System.out.println(Thread.currentThread().getName() + "\tEnd");
    }
    
}
```



CountDownLatch 主要有两个方法，当一个或多个线程调用 `await` 方法时，这些线程会阻塞

其他线程调用`CountDown()`方法会将计数器减1（调用CountDown方法的线程不会阻塞）

当计数器变为0时，await 方法阻塞的线程会被唤醒，继续执行



### CyclicBarrier

翻译：CyclicBarrier 篱栅

作用：和上面的减法相反，这里是加法，好比集齐7个龙珠召唤神龙，或者人到齐了再开会！

```java
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        // CyclicBarrier(int parties, Runnable barrierAction)
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println("召唤神龙成功");
        });

        for (int i = 1; i <= 7; i++) {
            final int tempInt = i;
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + 
                        "收集了第" + tempInt + "颗龙珠");

                try {
                    cyclicBarrier.await(); // 等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }

            }).start();
        }
    }
}
```



### Semaphore

翻译：Semaphore 信号量;信号灯;信号

举个“抢车位”的例子

```java
public class SemaphoreDemo {
    public static void main(String[] args) {
        // 模拟资源类，有3个空车位
        Semaphore semaphore = new Semaphore(3);
        for (int i = 1; i <= 6; i++) { // 模拟6个车
            new Thread(() -> {
                try {
                    semaphore.acquire(); // acquire 得到
                    System.out.println(Thread.currentThread().getName() + " 抢到了车位");
                    TimeUnit.SECONDS.sleep(3); // 停3秒钟
                    System.out.println(Thread.currentThread().getName() + " 离开了车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release(); // 释放这个位置
                }
            }, String.valueOf(i)).start();
        }

    }
}
```

在信号量上我们定义两种操作：

- acquire（获取）

  当一个线程调用 acquire 操作时，他要么通过成功获取信号量（信号量-1）

  要么一直等下去，直到有线程释放信号量，或超时

- release （释放）

  会将信号量的值 + 1，然后唤醒等待的线程

  

信号量主要用于两个目的：一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。

## 九 读写锁

**ReadWriteLock**

独占锁（写锁）：指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独占锁。

共享锁（读锁）：该锁可被多个线程所持有。

对于ReentrantReadWriteLock其读锁时共享锁，写锁是独占锁，读锁的共享锁可保证并发读是非常高效的。

```java
public class ReadWriteLockDemo {
    /**
     * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。
     * 但是，如果有一个线程想去写共享资源，就不应该再有其他线程可以对该资源进行读或写。
     * 1. 读-读 可以共存
     * 2. 读-写 不能共存
     * 3. 写-写 不能共存
     */
    public static void main(String[] args) {
        MyCacheLock myCache = new MyCacheLock();
        // 写
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.put(tempInt + "", tempInt + "");
            }, String.valueOf(i)).start();
        }

        // 读
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.get(tempInt + "");
            }, String.valueOf(i)).start();
        }
    }

}

// 测试发现问题: 写入的时候，还没写入完成，会存在其他的写入！造成问题
class MyCache {
    private volatile Map<String, Object> map = new HashMap<>();

    public void put(String key, Object value) {
        System.out.println(Thread.currentThread().getName() + " 写入" + key);
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + " 写入成功!");
    }

    public void get(String key) {
        System.out.println(Thread.currentThread().getName() + " 读取" + key);
        Object result = map.get(key);
        System.out.println(Thread.currentThread().getName() + " 读取结果：" + result);
    }
}

// 加锁
class MyCacheLock {
    private volatile Map<String, Object> map = new HashMap<>();
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); // 读写锁

    public void put(String key, Object value) {
        // 写锁
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 写入" + key);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + " 写入成功!");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //解锁
            readWriteLock.writeLock().unlock();
        }
    }

    public void get(String key) {
        // 读锁
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 读取" + key);
            Object result = map.get(key);
            System.out.println(Thread.currentThread().getName() + " 读取结果：" + result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
    }
}
```

## 十 阻塞队列

```java
Interface  BlockingQueue<E>
```

### 阻塞队列简介

阻塞：必须要阻塞、不得不阻塞

阻塞队列是一个队列，在数据结构中起的作用如下图：

![image-20210517173258323](https://cdn.jsdelivr.net/gh/oddfar/static/img/JUC学习笔记.assets/image-20210517173258323.png)

当队列是空的，从队列中**获取**元素的操作将会被阻塞。

当队列是满的，从队列中**添加**元素的操作将会被阻塞。

试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。

试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。

### 阻塞队列的用处

在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自 动被唤起。

为什么需要 BlockingQueue？

好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都 给你一手包办了。

在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。

### 接口架构图

![image-20210517173544418](https://cdn.jsdelivr.net/gh/oddfar/static/img/JUC学习笔记.assets/image-20210517173544418.png)

- ArrayBlockingQueue

  由数组结构组成的有界阻塞队列。

- LinkedBlockingQueue

  由链表结构组成的有界（默认值为：integer.MAX_VALUE）阻塞队列。

- PriorityBlockingQueue

  支持优先级排序的无界阻塞队列

- DelayQueue

  使用优先级队列实现的延迟无界阻塞队列。

- SynchronousQueue

  不存储元素的阻塞队列，也即单个元素的队列。

- LinkedTransferQueue

  由链表组成的无界阻塞队列

- LinkedBlockingDeque

  由链表组成的双向阻塞队列。

  

### API的使用

| 方法\处理方式 | 抛出异常  | 返回特殊值 | 一直阻塞 | 超时退出           |
| ------------- | --------- | ---------- | -------- | ------------------ |
| 插入方法      | add(e)    | offer(e)   | put(e)   | offer(e,time,unit) |
| 移除方法      | remove()  | poll()     | take()   | poll(time,unit)    |
| 检查方法      | element() | peek()     | 不可用   | 不可用             |

解释：

- 抛出异常

当阻塞队列满时，再往队列里add插入元素会抛出 `IllegalStateException: Queue full`

当阻塞队列空时，再往队列里remove移除元素会抛 NoSuchElementException` 

- 返回特殊值

插入方法，成功返回true，失败则false

移除方法，成功返回队列元素，队列里没有则返回null

- 一直阻塞

当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据或响应中断退出

当阻塞队列空时，消费者线程从队列里take元素，队列会一直阻塞消费者线程直到队列可用

- 超时退出

当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出



**抛出异常**

```java
package com.oddfar.bq;

import java.util.concurrent.ArrayBlockingQueue;

/**
 * @author zhiyuan
 */
public class BlockingQueueDemo {

    public static void main(String[] args) {
        // 队列大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("b"));
        System.out.println(blockingQueue.add("c"));

        //java.lang.IllegalStateException: Queue full
//        System.out.println(blockingQueue.add("d"));

        System.out.println("首元素：" + blockingQueue.element()); // 检测队列队首元素！
        // public E remove() 返回值E，就是移除的值
        System.out.println(blockingQueue.remove()); //a
        System.out.println(blockingQueue.remove()); //b
        System.out.println(blockingQueue.remove()); //c
        // java.util.NoSuchElementException
//        System.out.println(blockingQueue.remove());

    }
}
```

**返回特殊值**

```java
public class BlockingQueueDemo2 {
    public static void main(String[] args) {
        // 队列大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.offer("a")); // true
        System.out.println(blockingQueue.offer("b")); // true
        System.out.println(blockingQueue.offer("c")); // true
        //System.out.println(blockingQueue.offer("d")); // false

        System.out.println("首元素：" + blockingQueue.peek()); // 检测队列队首元素！

        // public E poll()
        System.out.println(blockingQueue.poll()); // a
        System.out.println(blockingQueue.poll()); // b
        System.out.println(blockingQueue.poll()); // c
        System.out.println(blockingQueue.poll()); // null
    }
}
```

**一直阻塞**

```java
public class BlockingQueueDemo3 {
    public static void main(String[] args) throws InterruptedException {
        // 队列大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

        // 一直阻塞
        blockingQueue.put("a");
        blockingQueue.put("b");
        blockingQueue.put("c");
//         blockingQueue.put("d");
        System.out.println(blockingQueue.take()); // a
        System.out.println(blockingQueue.take()); // b
        System.out.println(blockingQueue.take()); // c
        System.out.println(blockingQueue.take()); // 阻塞不停止等待
    }
}
```

**超时退出**

```java
public class BlockingQueueDemo4 {
    public static void main(String[] args) throws InterruptedException {
        // 队列大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

        // 一直阻塞
        blockingQueue.put("a");
        blockingQueue.put("b");
        blockingQueue.put("c");
        blockingQueue.offer("d",2L, TimeUnit.SECONDS); // 等待2秒超时退出

        System.out.println(blockingQueue.take()); // a
        System.out.println(blockingQueue.take()); // b
        System.out.println(blockingQueue.take()); // c
        System.out.println(blockingQueue.take()); // 阻塞不停止等待
    }
}
```