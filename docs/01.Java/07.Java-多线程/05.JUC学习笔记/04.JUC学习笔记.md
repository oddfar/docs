---
title: JUC学习笔记（二）
permalink: /java/se/thread/study-note/3
date: 2021-05-16 14:49:33liu6多线程下集合类的不安全
---


## 六 多线程下集合类的不安全

### list 

多线程下

```java
public class ListTest {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        // 对比3个线程 和 30个线程，看区别
        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
```

运行报错：`java.util.ConcurrentModificationException`

导致原因：add 方法没有加锁

解决方案：

```java
/**
 * 换一个集合类
 *  1、List<String> list = new Vector<>(); JDK1.0 就存在了！
 *  2、List<String> list = Collections.synchronizedList(new ArrayList<>());
 *  3、List<String> list = new CopyOnWriteArrayList<>();
 */
public class ListTest {
    public static void main(String[] args) {

        List<String> list = new CopyOnWriteArrayList<>();

        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
```

**写入时复制（CopyOnWrite）思想**

写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种优化策略。其核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本 （private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。

**CopyOnWriteArrayList为什么并发安全且性能比Vector好**

Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。

### set



```java
/**
 * 1、Set<String> set = Collections.synchronizedSet(new HashSet<>());
 * 2、Set<String> set = new CopyOnWriteArraySet();
 */
public class SetTest {
    public static void main(String[] args) {

        Set<String> set = new CopyOnWriteArraySet();

        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                set.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(set);
            }, String.valueOf(i)).start();
        }
    }
}
```

### map

hashMap底层是数组+链表+红黑树

```java
Map<String,String> map = new HashMap<>();
// 等价于
Map<String,String> map = new HashMap<>(16,0.75);
// 工作中，常常会自己根据业务来写参数，提高效率
```

map不安全测试：

```java
public class MapSet {
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>();

        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                map.put(Thread.currentThread().getName(),
                        UUID.randomUUID().toString().substring(0, 8));
                System.out.println(map);
            }, String.valueOf(i)).start();
        }
    }
}
```

解决：

```java
Map<String,String> map = new ConcurrentHashMap<>();
```

## 七 Callable

我们已经知道Java中常用的两种线程实现方式：分别是继承Thread类和实现Runnable接口。

![img](https://cdn.jsdelivr.net/gh/oddfar/static/img/JUC学习笔记.assets/95eef01f3a292df5cb9047105febf76635a87341.jpeg)

从上图中，我们可以看到，第三种实现Callable接口的线程，而且还带有返回值的。我们来对比下实现Runnable和实现Callable接口的两种方式不同点：

1：需要实现的方法名称不一样：一个run方法，一个call方法

2：返回值不同：一个void无返回值，一个带有返回值的。其中返回值的类型和泛型V是一致的。

3：异常：一个无需抛出异常，一个需要抛出异常。

### 基础入门

```java
public class CallableDemo {
    public static void main(String[] args) throws Exception {
        MyThread myThread = new MyThread();
        FutureTask futureTask = new FutureTask(myThread); // 适配类
        Thread t1 = new Thread(futureTask, "A"); // 调用执行
        t1.start();
        Integer result = (Integer) futureTask.get(); // 获取返回值
        System.out.println(result);
    }
}

class MyThread implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        System.out.println("call 被调用");
        return 1024;
    }
}
```

![image-20210516160612609](https://cdn.jsdelivr.net/gh/oddfar/static/img/JUC学习笔记.assets/image-20210516160612609.png)

### 多个线程调用

```java
public class CallableDemo {
    public static void main(String[] args) throws Exception {
        MyThread myThread = new MyThread();
        FutureTask futureTask = new FutureTask(myThread); // 适配类

        new Thread(futureTask, "A").start(); // 调用执行
        // 第二次调用执行，在同一个futureTask对象，不输出结果，可理解为“缓存”
        new Thread(futureTask, "B").start(); 

        //get 方法获得返回结果! 一般放在最后一行！否则可能会阻塞
        Integer result = (Integer) futureTask.get(); // 获取返回值
        System.out.println(result);
    }
}

class MyThread implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName() + "\tcall 被调用");
        TimeUnit.SECONDS.sleep(2);
        return 1024;
    }
}
```

### 参考资料

- https://baijiahao.baidu.com/s?id=1666820818587296272

## 八 常用辅助类

### CountDownLatch

“倒计时锁存器”

例如，执行完6个线程输出执行完毕

```java
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        // 计数器
        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\tStart");
                countDownLatch.countDown(); // 计数器-1
            }, String.valueOf(i)).start();
        }
        //阻塞等待计数器归零
        countDownLatch.await();
        System.out.println(Thread.currentThread().getName() + "\tEnd");
    }
    
}
```



CountDownLatch 主要有两个方法，当一个或多个线程调用 `await` 方法时，这些线程会阻塞

其他线程调用`CountDown()`方法会将计数器减1（调用CountDown方法的线程不会阻塞）

当计数器变为0时，await 方法阻塞的线程会被唤醒，继续执行



### CyclicBarrier

翻译：CyclicBarrier 篱栅

作用：和上面的减法相反，这里是加法，好比集齐7个龙珠召唤神龙，或者人到齐了再开会！

```java
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        // CyclicBarrier(int parties, Runnable barrierAction)
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println("召唤神龙成功");
        });

        for (int i = 1; i <= 7; i++) {
            final int tempInt = i;
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + 
                        "收集了第" + tempInt + "颗龙珠");

                try {
                    cyclicBarrier.await(); // 等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }

            }).start();
        }
    }
}
```



### Semaphore

翻译：Semaphore 信号量;信号灯;信号

举个“抢车位”的例子

```java
public class SemaphoreDemo {
    public static void main(String[] args) {
        // 模拟资源类，有3个空车位
        Semaphore semaphore = new Semaphore(3);
        for (int i = 1; i <= 6; i++) { // 模拟6个车
            new Thread(() -> {
                try {
                    semaphore.acquire(); // acquire 得到
                    System.out.println(Thread.currentThread().getName() + " 抢到了车位");
                    TimeUnit.SECONDS.sleep(3); // 停3秒钟
                    System.out.println(Thread.currentThread().getName() + " 离开了车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release(); // 释放这个位置
                }
            }, String.valueOf(i)).start();
        }

    }
}
```

在信号量上我们定义两种操作：

- acquire（获取）

  当一个线程调用 acquire 操作时，他要么通过成功获取信号量（信号量-1）

  要么一直等下去，直到有线程释放信号量，或超时

- release （释放）

  会将信号量的值 + 1，然后唤醒等待的线程

  

信号量主要用于两个目的：一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。

## 九 读写锁

**ReadWriteLock**

独占锁（写锁）：指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独占锁。

共享锁（读锁）：该锁可被多个线程所持有。

对于ReentrantReadWriteLock其读锁时共享锁，写锁是独占锁，读锁的共享锁可保证并发读是非常高效的。

```java
public class ReadWriteLockDemo {
    /**
     * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。
     * 但是，如果有一个线程想去写共享资源，就不应该再有其他线程可以对该资源进行读或写。
     * 1. 读-读 可以共存
     * 2. 读-写 不能共存
     * 3. 写-写 不能共存
     */
    public static void main(String[] args) {
        MyCacheLock myCache = new MyCacheLock();
        // 写
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.put(tempInt + "", tempInt + "");
            }, String.valueOf(i)).start();
        }

        // 读
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.get(tempInt + "");
            }, String.valueOf(i)).start();
        }
    }

}

// 测试发现问题: 写入的时候，还没写入完成，会存在其他的写入！造成问题
class MyCache {
    private volatile Map<String, Object> map = new HashMap<>();

    public void put(String key, Object value) {
        System.out.println(Thread.currentThread().getName() + " 写入" + key);
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + " 写入成功!");
    }

    public void get(String key) {
        System.out.println(Thread.currentThread().getName() + " 读取" + key);
        Object result = map.get(key);
        System.out.println(Thread.currentThread().getName() + " 读取结果：" + result);
    }
}

// 加锁
class MyCacheLock {
    private volatile Map<String, Object> map = new HashMap<>();
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); // 读写锁

    public void put(String key, Object value) {
        // 写锁
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 写入" + key);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + " 写入成功!");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //解锁
            readWriteLock.writeLock().unlock();
        }
    }

    public void get(String key) {
        // 读锁
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 读取" + key);
            Object result = map.get(key);
            System.out.println(Thread.currentThread().getName() + " 读取结果：" + result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
    }
}
```

